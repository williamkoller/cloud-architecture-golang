[![CI - Build and Test](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/ci.yml/badge.svg)](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/ci.yml)
[![CD - Deploy to AWS](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/deploy.yml/badge.svg)](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/deploy.yml)

# üöÄ Lambda Go com Terraform Modular na AWS

Este projeto implementa uma fun√ß√£o **AWS Lambda** escrita em Go, empacotada como imagem Docker e provisionada automaticamente com **Terraform** usando uma **arquitetura modular**.

A ideia √© simples: voc√™ escreve seu c√≥digo em Go ‚û° compila ‚û° empacota no Docker ‚û° envia para o **Amazon ECR** ‚û° Terraform modular provisiona tudo na AWS de forma organizada e reutiliz√°vel.

---

## üèóÔ∏è Arquitetura Modular

O projeto utiliza uma arquitetura Terraform modular para melhor organiza√ß√£o, manutenibilidade e reutiliza√ß√£o:

```
terraform/
‚îú‚îÄ‚îÄ main.tf                 # Orquestra√ß√£o dos m√≥dulos
‚îú‚îÄ‚îÄ variables.tf            # Vari√°veis globais
‚îú‚îÄ‚îÄ staging.tfvars         # Configura√ß√µes do ambiente staging
‚îú‚îÄ‚îÄ production.tfvars      # Configura√ß√µes do ambiente produ√ß√£o
‚îî‚îÄ‚îÄ modules/
    ‚îú‚îÄ‚îÄ ecr/               # Reposit√≥rio de containers
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ iam/               # Roles e pol√≠ticas
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ lambda/            # Fun√ß√£o Lambda
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ apigw/             # API Gateway
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ cloudwatch/        # Logs e alertas
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îú‚îÄ‚îÄ sns/               # Notifica√ß√µes
    ‚îÇ   ‚îú‚îÄ‚îÄ main.tf
    ‚îÇ   ‚îú‚îÄ‚îÄ outputs.tf
    ‚îÇ   ‚îî‚îÄ‚îÄ variables.tf
    ‚îî‚îÄ‚îÄ route53/           # DNS e health checks
        ‚îú‚îÄ‚îÄ main.tf
        ‚îú‚îÄ‚îÄ outputs.tf
        ‚îî‚îÄ‚îÄ variables.tf
```

### üîó Depend√™ncias entre M√≥dulos

```mermaid
graph TD
    A[ECR Module] --> D[Lambda Module]
    B[IAM Module] --> D[Lambda Module]
    D --> E[API Gateway Module]
    D --> F[CloudWatch Module]
    C[SNS Module] --> F
    E --> G[Route53 Module]
```

---

## üîÑ CI/CD Pipeline

O projeto implementa um pipeline CI/CD separado e robusto:

### üìã **CI (Continuous Integration)** - `.github/workflows/ci.yml`

**Executa em**: `push` para `main`, `develop`, `feature/*` e `pull_request` para `main`

**Jobs**:

1. **Lint & Code Quality**

   - go vet
   - gofmt (formata√ß√£o)
   - Verifica√ß√£o de depend√™ncias

2. **Unit Tests**

   - Execu√ß√£o de testes unit√°rios
   - Cobertura de c√≥digo
   - Upload de relat√≥rios

3. **Build & Docker**

   - Build da imagem Docker
   - Valida√ß√£o da imagem
   - Verifica√ß√£o do Terraform

**‚ö†Ô∏è Deployment s√≥ ocorre se TODOS os checks do CI passarem!**

### üöÄ **CD (Continuous Deployment)** - `.github/workflows/deploy.yml`

**Executa em**:

- Sucesso do workflow de CI na branch `main`
- Manualmente com `workflow_dispatch`

**Jobs**:

1. **Check CI Status** - Verifica se o CI passou
2. **Deploy to AWS** - Deploy completo na AWS
3. **Post-Deploy Notification** - Notifica√ß√£o do resultado

**Funcionalidades do Deploy**:

- ‚úÖ Verifica√ß√£o de depend√™ncias do CI
- ‚úÖ Build e push da imagem Docker
- ‚úÖ Atualiza√ß√£o da fun√ß√£o Lambda
- ‚úÖ Versionamento autom√°tico
- ‚úÖ Configura√ß√£o de alias `staging`
- ‚úÖ Verifica√ß√£o p√≥s-deploy
- ‚úÖ Deploy manual com op√ß√£o de for√ßa

---

## üì¶ Ferramentas AWS Utilizadas

- **AWS Lambda** ‚Äì Executa a fun√ß√£o Go usando container images
- **Amazon ECR** ‚Äì Armazena a imagem Docker da fun√ß√£o
- **API Gateway v2** ‚Äì Disponibiliza a fun√ß√£o como uma API HTTP
- **CloudWatch Logs** ‚Äì Armazena os logs da fun√ß√£o
- **CloudWatch Alarms** ‚Äì Monitora erros da Lambda
- **SNS (Simple Notification Service)** ‚Äì Envia alertas configurados
- **IAM (Identity and Access Management)** ‚Äì Controla permiss√µes
- **Route53** ‚Äì Health checks da aplica√ß√£o

---

## üîÑ Fluxo do Projeto

1. **Desenvolvimento**: Escrevemos o c√≥digo Go
2. **Build**: Compilamos o bin√°rio (`bootstrap`)
3. **Container**: Constru√≠mos a imagem Docker usando `public.ecr.aws/lambda/provided:al2`
4. **Registry**: Fazemos push para o **Amazon ECR**
5. **Infraestrutura**: O Terraform modular cria:
   - **ECR Module**: Reposit√≥rio de containers
   - **IAM Module**: Roles e pol√≠ticas de execu√ß√£o
   - **Lambda Module**: Fun√ß√£o Lambda + alias + concorr√™ncia provisionada
   - **API Gateway Module**: HTTP API com rotas
   - **CloudWatch Module**: Logs e alarmes
   - **SNS Module**: T√≥picos de notifica√ß√£o
   - **Route53 Module**: Health checks
6. **Deploy**: Chamamos a API e vemos a m√°gica acontecer ‚ú®

---

## üìã Pr√©-requisitos

- Go 1.24.5
- Docker
- AWS CLI configurado (`aws configure`)
- Terraform 1.5+
- Perfil AWS configurado (ex: `terraform-user`)

---

## ‚öôÔ∏è Configura√ß√£o

### 1. Configure suas vari√°veis de ambiente

Edite o arquivo `terraform/staging.tfvars`:

```hcl
env          = "staging"
aws_region   = "us-east-1"
account_id   = "SEU_ACCOUNT_ID"
image_tag    = "latest"
alert_email  = "seu@email.com"
aws_profile  = "terraform-user"
provisioned_concurrency = 0
```

### 2. Configure o arquivo `terraform/production.tfvars` para produ√ß√£o:

```hcl
env          = "production"
aws_region   = "us-east-1"
account_id   = "SEU_ACCOUNT_ID"
image_tag    = "v1.0.0"
alert_email  = "prod-alerts@empresa.com"
aws_profile  = "terraform-user"
provisioned_concurrency = 5
```

### 3. Configure secrets do GitHub Actions:

```bash
# No seu reposit√≥rio GitHub, v√° em Settings > Secrets and variables > Actions
# Adicione os seguintes secrets:

AWS_ACCESS_KEY_ID=SEU_ACCESS_KEY
AWS_SECRET_ACCESS_KEY=SEU_SECRET_KEY
AWS_ACCOUNT_ID=SEU_ACCOUNT_ID
```

---

## ‚ñ∂Ô∏è Como Executar

### üöÄ Deploy Local (Staging)

```bash
# 1Ô∏è‚É£ Compilar o Go e empacotar
./deploy.sh

# 2Ô∏è‚É£ Navegar para o diret√≥rio terraform
cd terraform

# 3Ô∏è‚É£ Inicializar Terraform
terraform init

# 4Ô∏è‚É£ Verificar o plano
terraform plan -var-file="staging.tfvars"

# 5Ô∏è‚É£ Aplicar a infraestrutura
terraform apply -var-file="staging.tfvars"
```

### üè≠ Deploy via CI/CD

```bash
# 1Ô∏è‚É£ Fazer push para uma feature branch
git checkout -b feature/nova-funcionalidade
git add .
git commit -m "feat: adiciona nova funcionalidade"
git push origin feature/nova-funcionalidade

# 2Ô∏è‚É£ Criar Pull Request para main
# - O CI executar√° automaticamente
# - Verificar√° c√≥digo, testes e build

# 3Ô∏è‚É£ Fazer merge para main
# - O CD executar√° automaticamente
# - Far√° deploy se CI passou com sucesso
```

### üß™ Executar Testes Localmente

```bash
# Executar todos os testes
go test -v ./...

# Executar com cobertura
go test -v -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html

# Executar linting
golangci-lint run ./...
```

### üß™ Testar a API

```bash
# Obter URL da API
terraform output api_gateway_url

# Testar endpoint de sa√∫de
curl https://SEU_API_ID.execute-api.us-east-1.amazonaws.com/health

# Testar endpoint de usu√°rios
curl https://SEU_API_ID.execute-api.us-east-1.amazonaws.com/users
```

---

## üßπ Limpeza

```bash
# Destruir ambiente staging
terraform destroy -var-file="staging.tfvars"

# Destruir ambiente produ√ß√£o
terraform workspace select production
terraform destroy -var-file="production.tfvars"
```

---

## üìä Outputs Dispon√≠veis

Ap√≥s o deploy, o Terraform fornece as seguintes informa√ß√µes:

- `api_gateway_url`: URL da API HTTP
- `lambda_function_arn`: ARN da fun√ß√£o Lambda
- `lambda_function_name`: Nome da fun√ß√£o Lambda
- `ecr_repository_url`: URL do reposit√≥rio ECR
- `health_check_id`: ID do health check Route53

---

## üîí Seguran√ßa

- ‚úÖ IAM roles com princ√≠pio do menor privil√©gio
- ‚úÖ Logs estruturados no CloudWatch
- ‚úÖ Alertas configurados para erros
- ‚úÖ Health checks autom√°ticos
- ‚úÖ Vari√°veis sens√≠veis em `.tfvars` (n√£o commitadas)
- ‚úÖ Security scanning no CI
- ‚úÖ Vulnerability scanning com Trivy

---

## üéØ Vantagens da Arquitetura Modular

1. **Reutiliza√ß√£o**: M√≥dulos podem ser reutilizados em diferentes projetos
2. **Manutenibilidade**: Cada m√≥dulo tem responsabilidade espec√≠fica
3. **Testabilidade**: M√≥dulos podem ser testados independentemente
4. **Escalabilidade**: F√°cil adicionar novos ambientes e funcionalidades
5. **Organiza√ß√£o**: C√≥digo bem estruturado e f√°cil de navegar
6. **Collabora√ß√£o**: Equipes podem trabalhar em m√≥dulos diferentes

---

## üö¶ Pipeline Status

| Workflow | Status                                                                                                                                                                                              | Descri√ß√£o                   |
| -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------- |
| CI       | [![CI](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/ci.yml/badge.svg)](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/ci.yml)         | Build, Test, Lint, Security |
| CD       | [![CD](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/deploy.yml/badge.svg)](https://github.com/williamkoller/cloud-architecture-golang/actions/workflows/deploy.yml) | Deploy para AWS             |

---

## ü§ù Contribui√ß√£o

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/AmazingFeature`)
3. Commit suas mudan√ßas (`git commit -m 'Add some AmazingFeature'`)
4. Push para a branch (`git push origin feature/AmazingFeature`)
5. Abra um Pull Request
6. Aguarde o CI passar ‚úÖ
7. Ap√≥s merge, o CD far√° deploy automaticamente üöÄ

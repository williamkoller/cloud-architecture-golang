name: CD - Deploy to AWS

on:
  workflow_run:
    workflows: ['CI - Build and Test']
    types:
      - completed
    branches: [main]

  # Permite deploy manual se necess√°rio
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if CI failed'
        type: boolean
        default: false

concurrency:
  group: lambda-deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: staging-lambda-go
  FUNCTION_NAME: staging-golang-api
  IMAGE_TAG: ${{ github.sha }}
  TARGET_PC: '2'
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}

jobs:
  # Job para verificar se o CI passou
  check-ci:
    name: Check CI Status
    runs-on: ubuntu-latest
    outputs:
      ci-passed: ${{ steps.check.outputs.ci-passed }}
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Check CI workflow status
        id: check
        run: |
          set -euo pipefail

          # Se foi acionado manualmente
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            if [[ "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
              echo "üö® Manual deploy with force flag - skipping CI check"
              echo "ci-passed=forced" >> "$GITHUB_OUTPUT"
              echo "should-deploy=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          # Verificar se o CI workflow passou
          if [[ "${{ github.event.workflow_run.conclusion }}" == "success" ]]; then
            echo "‚úÖ CI workflow passed successfully"
            echo "ci-passed=true" >> "$GITHUB_OUTPUT"
            echo "should-deploy=true" >> "$GITHUB_OUTPUT"
          else
            echo "‚ùå CI workflow failed or was cancelled"
            echo "ci-passed=false" >> "$GITHUB_OUTPUT"
            echo "should-deploy=false" >> "$GITHUB_OUTPUT"
            
            echo "CI Workflow conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Deployment will be skipped."
          fi

  # Job principal de deploy
  deploy:
    name: Deploy to AWS
    runs-on: ubuntu-latest
    needs: check-ci
    if: needs.check-ci.outputs.should-deploy == 'true'

    permissions:
      contents: read
      id-token: write # Para OIDC

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Compute deployment variables
        id: vars
        run: |
          set -euo pipefail
          IMAGE_URI="${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
          echo "image_uri=${IMAGE_URI}" >> "$GITHUB_OUTPUT"
          echo "üöÄ Deploying IMAGE_URI=${IMAGE_URI}"

          # Timestamp para logs
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          echo "timestamp=${TIMESTAMP}" >> "$GITHUB_OUTPUT"

      - name: Ensure ECR repository exists
        run: |
          set -euo pipefail
          echo "üì¶ Ensuring ECR repository exists..."
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || {
            echo "Creating ECR repository: $ECR_REPOSITORY"
            aws ecr create-repository --repository-name "$ECR_REPOSITORY" >/dev/null
          }

      - name: Login to ECR
        run: |
          set -euo pipefail
          echo "üîê Logging into ECR..."
          aws ecr get-login-password --region "$AWS_REGION" | \
            docker login --username AWS --password-stdin "${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build and push Docker image
        run: |
          set -euo pipefail
          echo "üèóÔ∏è Building Docker image for deployment..."

          # Build da imagem para produ√ß√£o
          docker build \
            --platform linux/amd64 \
            --tag "${ECR_REPOSITORY}:${IMAGE_TAG}" \
            --label "build.timestamp=${{ steps.vars.outputs.timestamp }}" \
            --label "build.sha=${GITHUB_SHA}" \
            --label "build.ref=${GITHUB_REF}" \
            .

          echo "üè∑Ô∏è Tagging image for ECR..."
          docker tag "${ECR_REPOSITORY}:${IMAGE_TAG}" "${{ steps.vars.outputs.image_uri }}"

          echo "üì§ Pushing image to ECR..."
          docker push "${{ steps.vars.outputs.image_uri }}"

          echo "‚úÖ Image pushed successfully"

      - name: Update Lambda function code
        id: update-lambda
        run: |
          set -euo pipefail
          echo "‚ö° Updating Lambda function code..."

          aws lambda update-function-code \
            --function-name "$FUNCTION_NAME" \
            --image-uri "${{ steps.vars.outputs.image_uri }}" \
            --no-cli-pager

          echo "‚úÖ Lambda code updated"

      - name: Wait for function update to complete
        run: |
          set -euo pipefail
          echo "‚è≥ Waiting for Lambda function to update..."

          aws lambda wait function-updated \
            --function-name "$FUNCTION_NAME" \
            --cli-read-timeout 300 \
            --cli-poll-delay 5

          echo "‚úÖ Lambda function updated successfully"

      - name: Publish new Lambda version
        id: publish
        run: |
          set -euo pipefail
          echo "üìã Publishing new Lambda version..."

          VERSION=$(aws lambda publish-version \
            --function-name "$FUNCTION_NAME" \
            --description "Deploy from commit ${GITHUB_SHA} at ${{ steps.vars.outputs.timestamp }}" \
            --query 'Version' \
            --output text)

          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Published version: $VERSION"

      - name: Update staging alias
        run: |
          set -euo pipefail
          echo "üîÑ Updating staging alias..."

          ALIAS="staging"
          VERSION="${{ steps.publish.outputs.version }}"

          if aws lambda get-alias --function-name "$FUNCTION_NAME" --name "$ALIAS" >/dev/null 2>&1; then
            echo "Updating existing alias..."
            aws lambda update-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS" \
              --function-version "$VERSION" \
              --description "Updated at ${{ steps.vars.outputs.timestamp }}" \
              --no-cli-pager
          else
            echo "Creating new alias..."
            aws lambda create-alias \
              --function-name "$FUNCTION_NAME" \
              --name "$ALIAS" \
              --function-version "$VERSION" \
              --description "Created at ${{ steps.vars.outputs.timestamp }}" \
              --no-cli-pager
          fi

          echo "‚úÖ Staging alias updated to version $VERSION"

      - name: Configure provisioned concurrency
        id: pc
        run: |
          set -euo pipefail
          echo "üöÄ Configuring provisioned concurrency..."

          TARGET_PC="${TARGET_PC:-0}"
          TARGET_PC=$((TARGET_PC + 0))

          echo "Requested TARGET_PC: ${TARGET_PC}"

          if [ "${TARGET_PC}" -eq 0 ]; then
            echo "TARGET_PC is 0, skipping provisioned concurrency setup"
            echo "can_set_pc=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Verificar capacidade dispon√≠vel
          UNRESERVED=$(aws lambda get-account-settings \
            --query 'AccountLimit.UnreservedConcurrentExecutions' \
            --output text)
          UNRESERVED=$((UNRESERVED + 0))

          echo "Account UnreservedConcurrentExecutions: ${UNRESERVED}"

          if [ "${UNRESERVED}" -ge $((TARGET_PC + 10)) ]; then
            echo "‚úÖ Sufficient capacity for provisioned concurrency = ${TARGET_PC}"
            echo "can_set_pc=true" >> "$GITHUB_OUTPUT"
            echo "pc_value=${TARGET_PC}" >> "$GITHUB_OUTPUT"
          else
            echo "‚ö†Ô∏è  Insufficient capacity for PC=${TARGET_PC} (needs >= 10 buffer). Skipping."
            echo "can_set_pc=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Set provisioned concurrency
        if: steps.pc.outputs.can_set_pc == 'true'
        run: |
          set -euo pipefail
          echo "‚ö° Setting provisioned concurrency..."

          # Aguardar um pouco antes de configurar PC
          sleep 10

          aws lambda put-provisioned-concurrency-config \
            --function-name "$FUNCTION_NAME" \
            --qualifier staging \
            --provisioned-concurrent-executions "${{ steps.pc.outputs.pc_value }}"

          echo "‚úÖ Provisioned concurrency configured"

      - name: Wait for provisioned concurrency to be ready
        if: steps.pc.outputs.can_set_pc == 'true'
        run: |
          set -euo pipefail
          echo "‚è≥ Waiting for provisioned concurrency to be ready..."

          for i in {1..60}; do
            STATUS=$(aws lambda get-provisioned-concurrency-config \
              --function-name "$FUNCTION_NAME" \
              --qualifier staging \
              --query 'Status' \
              --output text 2>/dev/null || echo "UNKNOWN")
            
            echo "Provisioned Concurrency Status (attempt $i/60): $STATUS"
            
            case "$STATUS" in
              "READY")
                echo "‚úÖ Provisioned concurrency is READY"
                exit 0
                ;;
              "FAILED")
                echo "‚ùå Provisioned concurrency FAILED"
                aws lambda get-provisioned-concurrency-config \
                  --function-name "$FUNCTION_NAME" \
                  --qualifier staging || true
                exit 1
                ;;
              "IN_PROGRESS"|"UNKNOWN")
                echo "‚è≥ Still in progress, waiting..."
                sleep 10
                ;;
              *)
                echo "‚ö†Ô∏è  Unknown status: $STATUS"
                sleep 10
                ;;
            esac
          done

          echo "‚è∞ Timeout waiting for provisioned concurrency to be ready"
          exit 1

      - name: Verify deployment
        run: |
          set -euo pipefail
          echo "üîç Verifying deployment..."

          # Obter informa√ß√µes da fun√ß√£o atualizada
          CURRENT_IMAGE=$(aws lambda get-function \
            --function-name "$FUNCTION_NAME" \
            --qualifier staging \
            --query 'Code.ImageUri' \
            --output text)

          echo "‚úÖ Current image URI: $CURRENT_IMAGE"

          # Verificar se a imagem corresponde ao que deploying
          if [[ "$CURRENT_IMAGE" == *"$IMAGE_TAG"* ]]; then
            echo "‚úÖ Deployment verification successful!"
          else
            echo "‚ùå Deployment verification failed - image mismatch"
            echo "Expected: ${{ steps.vars.outputs.image_uri }}"
            echo "Actual: $CURRENT_IMAGE"
            exit 1
          fi

  # Job de notifica√ß√£o p√≥s-deploy
  notify:
    name: Post-Deploy Notification
    runs-on: ubuntu-latest
    needs: [check-ci, deploy]
    if: always() && needs.check-ci.outputs.should-deploy == 'true'
    steps:
      - name: Deploy status notification
        run: |
          set -euo pipefail

          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "üéâ DEPLOYMENT SUCCESSFUL!"
            echo "‚úÖ Function: $FUNCTION_NAME"
            echo "‚úÖ Image: ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${IMAGE_TAG}"
            echo "‚úÖ Commit: ${GITHUB_SHA}"
            echo "‚úÖ Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          else
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "Check the logs above for details."
            exit 1
          fi
